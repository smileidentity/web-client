(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // ../../node_modules/validate.js/validate.js
  var require_validate = __commonJS({
    "../../node_modules/validate.js/validate.js"(exports, module) {
      (function(exports2, module2, define2) {
        "use strict";
        var validate2 = function(attributes, constraints, options) {
          options = v.extend({}, v.options, options);
          var results = v.runValidations(attributes, constraints, options), attr, validator;
          if (results.some(function(r) {
            return v.isPromise(r.error);
          })) {
            throw new Error("Use validate.async if you want support for promises");
          }
          return validate2.processValidationResults(results, options);
        };
        var v = validate2;
        v.extend = function(obj) {
          [].slice.call(arguments, 1).forEach(function(source) {
            for (var attr in source) {
              obj[attr] = source[attr];
            }
          });
          return obj;
        };
        v.extend(validate2, {
          // This is the version of the library as a semver.
          // The toString function will allow it to be coerced into a string
          version: {
            major: 0,
            minor: 13,
            patch: 1,
            metadata: null,
            toString: function() {
              var version2 = v.format("%{major}.%{minor}.%{patch}", v.version);
              if (!v.isEmpty(v.version.metadata)) {
                version2 += "+" + v.version.metadata;
              }
              return version2;
            }
          },
          // Below is the dependencies that are used in validate.js
          // The constructor of the Promise implementation.
          // If you are using Q.js, RSVP or any other A+ compatible implementation
          // override this attribute to be the constructor of that promise.
          // Since jQuery promises aren't A+ compatible they won't work.
          Promise: typeof Promise !== "undefined" ? Promise : (
            /* istanbul ignore next */
            null
          ),
          EMPTY_STRING_REGEXP: /^\s*$/,
          // Runs the validators specified by the constraints object.
          // Will return an array of the format:
          //     [{attribute: "<attribute name>", error: "<validation result>"}, ...]
          runValidations: function(attributes, constraints, options) {
            var results = [], attr, validatorName, value, validators, validator, validatorOptions, error;
            if (v.isDomElement(attributes) || v.isJqueryElement(attributes)) {
              attributes = v.collectFormValues(attributes);
            }
            for (attr in constraints) {
              value = v.getDeepObjectValue(attributes, attr);
              validators = v.result(constraints[attr], value, attributes, attr, options, constraints);
              for (validatorName in validators) {
                validator = v.validators[validatorName];
                if (!validator) {
                  error = v.format("Unknown validator %{name}", { name: validatorName });
                  throw new Error(error);
                }
                validatorOptions = validators[validatorName];
                validatorOptions = v.result(validatorOptions, value, attributes, attr, options, constraints);
                if (!validatorOptions) {
                  continue;
                }
                results.push({
                  attribute: attr,
                  value,
                  validator: validatorName,
                  globalOptions: options,
                  attributes,
                  options: validatorOptions,
                  error: validator.call(
                    validator,
                    value,
                    validatorOptions,
                    attr,
                    attributes,
                    options
                  )
                });
              }
            }
            return results;
          },
          // Takes the output from runValidations and converts it to the correct
          // output format.
          processValidationResults: function(errors, options) {
            errors = v.pruneEmptyErrors(errors, options);
            errors = v.expandMultipleErrors(errors, options);
            errors = v.convertErrorMessages(errors, options);
            var format = options.format || "grouped";
            if (typeof v.formatters[format] === "function") {
              errors = v.formatters[format](errors);
            } else {
              throw new Error(v.format("Unknown format %{format}", options));
            }
            return v.isEmpty(errors) ? void 0 : errors;
          },
          // Runs the validations with support for promises.
          // This function will return a promise that is settled when all the
          // validation promises have been completed.
          // It can be called even if no validations returned a promise.
          async: function(attributes, constraints, options) {
            options = v.extend({}, v.async.options, options);
            var WrapErrors = options.wrapErrors || function(errors) {
              return errors;
            };
            if (options.cleanAttributes !== false) {
              attributes = v.cleanAttributes(attributes, constraints);
            }
            var results = v.runValidations(attributes, constraints, options);
            return new v.Promise(function(resolve, reject) {
              v.waitForResults(results).then(function() {
                var errors = v.processValidationResults(results, options);
                if (errors) {
                  reject(new WrapErrors(errors, options, attributes, constraints));
                } else {
                  resolve(attributes);
                }
              }, function(err) {
                reject(err);
              });
            });
          },
          single: function(value, constraints, options) {
            options = v.extend({}, v.single.options, options, {
              format: "flat",
              fullMessages: false
            });
            return v({ single: value }, { single: constraints }, options);
          },
          // Returns a promise that is resolved when all promises in the results array
          // are settled. The promise returned from this function is always resolved,
          // never rejected.
          // This function modifies the input argument, it replaces the promises
          // with the value returned from the promise.
          waitForResults: function(results) {
            return results.reduce(function(memo, result) {
              if (!v.isPromise(result.error)) {
                return memo;
              }
              return memo.then(function() {
                return result.error.then(function(error) {
                  result.error = error || null;
                });
              });
            }, new v.Promise(function(r) {
              r();
            }));
          },
          // If the given argument is a call: function the and: function return the value
          // otherwise just return the value. Additional arguments will be passed as
          // arguments to the function.
          // Example:
          // ```
          // result('foo') // 'foo'
          // result(Math.max, 1, 2) // 2
          // ```
          result: function(value) {
            var args = [].slice.call(arguments, 1);
            if (typeof value === "function") {
              value = value.apply(null, args);
            }
            return value;
          },
          // Checks if the value is a number. This function does not consider NaN a
          // number like many other `isNumber` functions do.
          isNumber: function(value) {
            return typeof value === "number" && !isNaN(value);
          },
          // Returns false if the object is not a function
          isFunction: function(value) {
            return typeof value === "function";
          },
          // A simple check to verify that the value is an integer. Uses `isNumber`
          // and a simple modulo check.
          isInteger: function(value) {
            return v.isNumber(value) && value % 1 === 0;
          },
          // Checks if the value is a boolean
          isBoolean: function(value) {
            return typeof value === "boolean";
          },
          // Uses the `Object` function to check if the given argument is an object.
          isObject: function(obj) {
            return obj === Object(obj);
          },
          // Simply checks if the object is an instance of a date
          isDate: function(obj) {
            return obj instanceof Date;
          },
          // Returns false if the object is `null` of `undefined`
          isDefined: function(obj) {
            return obj !== null && obj !== void 0;
          },
          // Checks if the given argument is a promise. Anything with a `then`
          // function is considered a promise.
          isPromise: function(p) {
            return !!p && v.isFunction(p.then);
          },
          isJqueryElement: function(o) {
            return o && v.isString(o.jquery);
          },
          isDomElement: function(o) {
            if (!o) {
              return false;
            }
            if (!o.querySelectorAll || !o.querySelector) {
              return false;
            }
            if (v.isObject(document) && o === document) {
              return true;
            }
            if (typeof HTMLElement === "object") {
              return o instanceof HTMLElement;
            } else {
              return o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
            }
          },
          isEmpty: function(value) {
            var attr;
            if (!v.isDefined(value)) {
              return true;
            }
            if (v.isFunction(value)) {
              return false;
            }
            if (v.isString(value)) {
              return v.EMPTY_STRING_REGEXP.test(value);
            }
            if (v.isArray(value)) {
              return value.length === 0;
            }
            if (v.isDate(value)) {
              return false;
            }
            if (v.isObject(value)) {
              for (attr in value) {
                return false;
              }
              return true;
            }
            return false;
          },
          // Formats the specified strings with the given values like so:
          // ```
          // format("Foo: %{foo}", {foo: "bar"}) // "Foo bar"
          // ```
          // If you want to write %{...} without having it replaced simply
          // prefix it with % like this `Foo: %%{foo}` and it will be returned
          // as `"Foo: %{foo}"`
          format: v.extend(function(str, vals) {
            if (!v.isString(str)) {
              return str;
            }
            return str.replace(v.format.FORMAT_REGEXP, function(m0, m1, m2) {
              if (m1 === "%") {
                return "%{" + m2 + "}";
              } else {
                return String(vals[m2]);
              }
            });
          }, {
            // Finds %{key} style patterns in the given string
            FORMAT_REGEXP: /(%?)%\{([^\}]+)\}/g
          }),
          // "Prettifies" the given string.
          // Prettifying means replacing [.\_-] with spaces as well as splitting
          // camel case words.
          prettify: function(str) {
            if (v.isNumber(str)) {
              if (str * 100 % 1 === 0) {
                return "" + str;
              } else {
                return parseFloat(Math.round(str * 100) / 100).toFixed(2);
              }
            }
            if (v.isArray(str)) {
              return str.map(function(s) {
                return v.prettify(s);
              }).join(", ");
            }
            if (v.isObject(str)) {
              if (!v.isDefined(str.toString)) {
                return JSON.stringify(str);
              }
              return str.toString();
            }
            str = "" + str;
            return str.replace(/([^\s])\.([^\s])/g, "$1 $2").replace(/\\+/g, "").replace(/[_-]/g, " ").replace(/([a-z])([A-Z])/g, function(m0, m1, m2) {
              return "" + m1 + " " + m2.toLowerCase();
            }).toLowerCase();
          },
          stringifyValue: function(value, options) {
            var prettify = options && options.prettify || v.prettify;
            return prettify(value);
          },
          isString: function(value) {
            return typeof value === "string";
          },
          isArray: function(value) {
            return {}.toString.call(value) === "[object Array]";
          },
          // Checks if the object is a hash, which is equivalent to an object that
          // is neither an array nor a function.
          isHash: function(value) {
            return v.isObject(value) && !v.isArray(value) && !v.isFunction(value);
          },
          contains: function(obj, value) {
            if (!v.isDefined(obj)) {
              return false;
            }
            if (v.isArray(obj)) {
              return obj.indexOf(value) !== -1;
            }
            return value in obj;
          },
          unique: function(array) {
            if (!v.isArray(array)) {
              return array;
            }
            return array.filter(function(el, index, array2) {
              return array2.indexOf(el) == index;
            });
          },
          forEachKeyInKeypath: function(object, keypath, callback) {
            if (!v.isString(keypath)) {
              return void 0;
            }
            var key = "", i, escape = false;
            for (i = 0; i < keypath.length; ++i) {
              switch (keypath[i]) {
                case ".":
                  if (escape) {
                    escape = false;
                    key += ".";
                  } else {
                    object = callback(object, key, false);
                    key = "";
                  }
                  break;
                case "\\":
                  if (escape) {
                    escape = false;
                    key += "\\";
                  } else {
                    escape = true;
                  }
                  break;
                default:
                  escape = false;
                  key += keypath[i];
                  break;
              }
            }
            return callback(object, key, true);
          },
          getDeepObjectValue: function(obj, keypath) {
            if (!v.isObject(obj)) {
              return void 0;
            }
            return v.forEachKeyInKeypath(obj, keypath, function(obj2, key) {
              if (v.isObject(obj2)) {
                return obj2[key];
              }
            });
          },
          // This returns an object with all the values of the form.
          // It uses the input name as key and the value as value
          // So for example this:
          // <input type="text" name="email" value="foo@bar.com" />
          // would return:
          // {email: "foo@bar.com"}
          collectFormValues: function(form, options) {
            var values = {}, i, j, input, inputs, option, value;
            if (v.isJqueryElement(form)) {
              form = form[0];
            }
            if (!form) {
              return values;
            }
            options = options || {};
            inputs = form.querySelectorAll("input[name], textarea[name]");
            for (i = 0; i < inputs.length; ++i) {
              input = inputs.item(i);
              if (v.isDefined(input.getAttribute("data-ignored"))) {
                continue;
              }
              var name = input.name.replace(/\./g, "\\\\.");
              value = v.sanitizeFormValue(input.value, options);
              if (input.type === "number") {
                value = value ? +value : null;
              } else if (input.type === "checkbox") {
                if (input.attributes.value) {
                  if (!input.checked) {
                    value = values[name] || null;
                  }
                } else {
                  value = input.checked;
                }
              } else if (input.type === "radio") {
                if (!input.checked) {
                  value = values[name] || null;
                }
              }
              values[name] = value;
            }
            inputs = form.querySelectorAll("select[name]");
            for (i = 0; i < inputs.length; ++i) {
              input = inputs.item(i);
              if (v.isDefined(input.getAttribute("data-ignored"))) {
                continue;
              }
              if (input.multiple) {
                value = [];
                for (j in input.options) {
                  option = input.options[j];
                  if (option && option.selected) {
                    value.push(v.sanitizeFormValue(option.value, options));
                  }
                }
              } else {
                var _val = typeof input.options[input.selectedIndex] !== "undefined" ? input.options[input.selectedIndex].value : (
                  /* istanbul ignore next */
                  ""
                );
                value = v.sanitizeFormValue(_val, options);
              }
              values[input.name] = value;
            }
            return values;
          },
          sanitizeFormValue: function(value, options) {
            if (options.trim && v.isString(value)) {
              value = value.trim();
            }
            if (options.nullify !== false && value === "") {
              return null;
            }
            return value;
          },
          capitalize: function(str) {
            if (!v.isString(str)) {
              return str;
            }
            return str[0].toUpperCase() + str.slice(1);
          },
          // Remove all errors who's error attribute is empty (null or undefined)
          pruneEmptyErrors: function(errors) {
            return errors.filter(function(error) {
              return !v.isEmpty(error.error);
            });
          },
          // In
          // [{error: ["err1", "err2"], ...}]
          // Out
          // [{error: "err1", ...}, {error: "err2", ...}]
          //
          // All attributes in an error with multiple messages are duplicated
          // when expanding the errors.
          expandMultipleErrors: function(errors) {
            var ret = [];
            errors.forEach(function(error) {
              if (v.isArray(error.error)) {
                error.error.forEach(function(msg) {
                  ret.push(v.extend({}, error, { error: msg }));
                });
              } else {
                ret.push(error);
              }
            });
            return ret;
          },
          // Converts the error mesages by prepending the attribute name unless the
          // message is prefixed by ^
          convertErrorMessages: function(errors, options) {
            options = options || {};
            var ret = [], prettify = options.prettify || v.prettify;
            errors.forEach(function(errorInfo) {
              var error = v.result(
                errorInfo.error,
                errorInfo.value,
                errorInfo.attribute,
                errorInfo.options,
                errorInfo.attributes,
                errorInfo.globalOptions
              );
              if (!v.isString(error)) {
                ret.push(errorInfo);
                return;
              }
              if (error[0] === "^") {
                error = error.slice(1);
              } else if (options.fullMessages !== false) {
                error = v.capitalize(prettify(errorInfo.attribute)) + " " + error;
              }
              error = error.replace(/\\\^/g, "^");
              error = v.format(error, {
                value: v.stringifyValue(errorInfo.value, options)
              });
              ret.push(v.extend({}, errorInfo, { error }));
            });
            return ret;
          },
          // In:
          // [{attribute: "<attributeName>", ...}]
          // Out:
          // {"<attributeName>": [{attribute: "<attributeName>", ...}]}
          groupErrorsByAttribute: function(errors) {
            var ret = {};
            errors.forEach(function(error) {
              var list = ret[error.attribute];
              if (list) {
                list.push(error);
              } else {
                ret[error.attribute] = [error];
              }
            });
            return ret;
          },
          // In:
          // [{error: "<message 1>", ...}, {error: "<message 2>", ...}]
          // Out:
          // ["<message 1>", "<message 2>"]
          flattenErrorsToArray: function(errors) {
            return errors.map(function(error) {
              return error.error;
            }).filter(function(value, index, self) {
              return self.indexOf(value) === index;
            });
          },
          cleanAttributes: function(attributes, whitelist) {
            function whitelistCreator(obj, key, last) {
              if (v.isObject(obj[key])) {
                return obj[key];
              }
              return obj[key] = last ? true : {};
            }
            function buildObjectWhitelist(whitelist2) {
              var ow = {}, lastObject, attr;
              for (attr in whitelist2) {
                if (!whitelist2[attr]) {
                  continue;
                }
                v.forEachKeyInKeypath(ow, attr, whitelistCreator);
              }
              return ow;
            }
            function cleanRecursive(attributes2, whitelist2) {
              if (!v.isObject(attributes2)) {
                return attributes2;
              }
              var ret = v.extend({}, attributes2), w, attribute;
              for (attribute in attributes2) {
                w = whitelist2[attribute];
                if (v.isObject(w)) {
                  ret[attribute] = cleanRecursive(ret[attribute], w);
                } else if (!w) {
                  delete ret[attribute];
                }
              }
              return ret;
            }
            if (!v.isObject(whitelist) || !v.isObject(attributes)) {
              return {};
            }
            whitelist = buildObjectWhitelist(whitelist);
            return cleanRecursive(attributes, whitelist);
          },
          exposeModule: function(validate3, root, exports3, module3, define3) {
            if (exports3) {
              if (module3 && module3.exports) {
                exports3 = module3.exports = validate3;
              }
              exports3.validate = validate3;
            } else {
              root.validate = validate3;
              if (validate3.isFunction(define3) && define3.amd) {
                define3([], function() {
                  return validate3;
                });
              }
            }
          },
          warn: function(msg) {
            if (typeof console !== "undefined" && console.warn) {
              console.warn("[validate.js] " + msg);
            }
          },
          error: function(msg) {
            if (typeof console !== "undefined" && console.error) {
              console.error("[validate.js] " + msg);
            }
          }
        });
        validate2.validators = {
          // Presence validates that the value isn't empty
          presence: function(value, options) {
            options = v.extend({}, this.options, options);
            if (options.allowEmpty !== false ? !v.isDefined(value) : v.isEmpty(value)) {
              return options.message || this.message || "can't be blank";
            }
          },
          length: function(value, options, attribute) {
            if (!v.isDefined(value)) {
              return;
            }
            options = v.extend({}, this.options, options);
            var is = options.is, maximum = options.maximum, minimum = options.minimum, tokenizer = options.tokenizer || function(val) {
              return val;
            }, err, errors = [];
            value = tokenizer(value);
            var length = value.length;
            if (!v.isNumber(length)) {
              return options.message || this.notValid || "has an incorrect length";
            }
            if (v.isNumber(is) && length !== is) {
              err = options.wrongLength || this.wrongLength || "is the wrong length (should be %{count} characters)";
              errors.push(v.format(err, { count: is }));
            }
            if (v.isNumber(minimum) && length < minimum) {
              err = options.tooShort || this.tooShort || "is too short (minimum is %{count} characters)";
              errors.push(v.format(err, { count: minimum }));
            }
            if (v.isNumber(maximum) && length > maximum) {
              err = options.tooLong || this.tooLong || "is too long (maximum is %{count} characters)";
              errors.push(v.format(err, { count: maximum }));
            }
            if (errors.length > 0) {
              return options.message || errors;
            }
          },
          numericality: function(value, options, attribute, attributes, globalOptions) {
            if (!v.isDefined(value)) {
              return;
            }
            options = v.extend({}, this.options, options);
            var errors = [], name, count, checks = {
              greaterThan: function(v2, c) {
                return v2 > c;
              },
              greaterThanOrEqualTo: function(v2, c) {
                return v2 >= c;
              },
              equalTo: function(v2, c) {
                return v2 === c;
              },
              lessThan: function(v2, c) {
                return v2 < c;
              },
              lessThanOrEqualTo: function(v2, c) {
                return v2 <= c;
              },
              divisibleBy: function(v2, c) {
                return v2 % c === 0;
              }
            }, prettify = options.prettify || globalOptions && globalOptions.prettify || v.prettify;
            if (v.isString(value) && options.strict) {
              var pattern = "^-?(0|[1-9]\\d*)";
              if (!options.onlyInteger) {
                pattern += "(\\.\\d+)?";
              }
              pattern += "$";
              if (!new RegExp(pattern).test(value)) {
                return options.message || options.notValid || this.notValid || this.message || "must be a valid number";
              }
            }
            if (options.noStrings !== true && v.isString(value) && !v.isEmpty(value)) {
              value = +value;
            }
            if (!v.isNumber(value)) {
              return options.message || options.notValid || this.notValid || this.message || "is not a number";
            }
            if (options.onlyInteger && !v.isInteger(value)) {
              return options.message || options.notInteger || this.notInteger || this.message || "must be an integer";
            }
            for (name in checks) {
              count = options[name];
              if (v.isNumber(count) && !checks[name](value, count)) {
                var key = "not" + v.capitalize(name);
                var msg = options[key] || this[key] || this.message || "must be %{type} %{count}";
                errors.push(v.format(msg, {
                  count,
                  type: prettify(name)
                }));
              }
            }
            if (options.odd && value % 2 !== 1) {
              errors.push(options.notOdd || this.notOdd || this.message || "must be odd");
            }
            if (options.even && value % 2 !== 0) {
              errors.push(options.notEven || this.notEven || this.message || "must be even");
            }
            if (errors.length) {
              return options.message || errors;
            }
          },
          datetime: v.extend(function(value, options) {
            if (!v.isFunction(this.parse) || !v.isFunction(this.format)) {
              throw new Error("Both the parse and format functions needs to be set to use the datetime/date validator");
            }
            if (!v.isDefined(value)) {
              return;
            }
            options = v.extend({}, this.options, options);
            var err, errors = [], earliest = options.earliest ? this.parse(options.earliest, options) : NaN, latest = options.latest ? this.parse(options.latest, options) : NaN;
            value = this.parse(value, options);
            if (isNaN(value) || options.dateOnly && value % 864e5 !== 0) {
              err = options.notValid || options.message || this.notValid || "must be a valid date";
              return v.format(err, { value: arguments[0] });
            }
            if (!isNaN(earliest) && value < earliest) {
              err = options.tooEarly || options.message || this.tooEarly || "must be no earlier than %{date}";
              err = v.format(err, {
                value: this.format(value, options),
                date: this.format(earliest, options)
              });
              errors.push(err);
            }
            if (!isNaN(latest) && value > latest) {
              err = options.tooLate || options.message || this.tooLate || "must be no later than %{date}";
              err = v.format(err, {
                date: this.format(latest, options),
                value: this.format(value, options)
              });
              errors.push(err);
            }
            if (errors.length) {
              return v.unique(errors);
            }
          }, {
            parse: null,
            format: null
          }),
          date: function(value, options) {
            options = v.extend({}, options, { dateOnly: true });
            return v.validators.datetime.call(v.validators.datetime, value, options);
          },
          format: function(value, options) {
            if (v.isString(options) || options instanceof RegExp) {
              options = { pattern: options };
            }
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || "is invalid", pattern = options.pattern, match;
            if (!v.isDefined(value)) {
              return;
            }
            if (!v.isString(value)) {
              return message;
            }
            if (v.isString(pattern)) {
              pattern = new RegExp(options.pattern, options.flags);
            }
            match = pattern.exec(value);
            if (!match || match[0].length != value.length) {
              return message;
            }
          },
          inclusion: function(value, options) {
            if (!v.isDefined(value)) {
              return;
            }
            if (v.isArray(options)) {
              options = { within: options };
            }
            options = v.extend({}, this.options, options);
            if (v.contains(options.within, value)) {
              return;
            }
            var message = options.message || this.message || "^%{value} is not included in the list";
            return v.format(message, { value });
          },
          exclusion: function(value, options) {
            if (!v.isDefined(value)) {
              return;
            }
            if (v.isArray(options)) {
              options = { within: options };
            }
            options = v.extend({}, this.options, options);
            if (!v.contains(options.within, value)) {
              return;
            }
            var message = options.message || this.message || "^%{value} is restricted";
            if (v.isString(options.within[value])) {
              value = options.within[value];
            }
            return v.format(message, { value });
          },
          email: v.extend(function(value, options) {
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || "is not a valid email";
            if (!v.isDefined(value)) {
              return;
            }
            if (!v.isString(value)) {
              return message;
            }
            if (!this.PATTERN.exec(value)) {
              return message;
            }
          }, {
            PATTERN: /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i
          }),
          equality: function(value, options, attribute, attributes, globalOptions) {
            if (!v.isDefined(value)) {
              return;
            }
            if (v.isString(options)) {
              options = { attribute: options };
            }
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || "is not equal to %{attribute}";
            if (v.isEmpty(options.attribute) || !v.isString(options.attribute)) {
              throw new Error("The attribute must be a non empty string");
            }
            var otherValue = v.getDeepObjectValue(attributes, options.attribute), comparator = options.comparator || function(v1, v2) {
              return v1 === v2;
            }, prettify = options.prettify || globalOptions && globalOptions.prettify || v.prettify;
            if (!comparator(value, otherValue, options, attribute, attributes)) {
              return v.format(message, { attribute: prettify(options.attribute) });
            }
          },
          // A URL validator that is used to validate URLs with the ability to
          // restrict schemes and some domains.
          url: function(value, options) {
            if (!v.isDefined(value)) {
              return;
            }
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || "is not a valid url", schemes = options.schemes || this.schemes || ["http", "https"], allowLocal = options.allowLocal || this.allowLocal || false, allowDataUrl = options.allowDataUrl || this.allowDataUrl || false;
            if (!v.isString(value)) {
              return message;
            }
            var regex = "^(?:(?:" + schemes.join("|") + ")://)(?:\\S+(?::\\S*)?@)?(?:";
            var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
            if (allowLocal) {
              tld += "?";
            } else {
              regex += // IP address exclusion
              // private & local networks
              "(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})";
            }
            regex += // IP address dotted notation octets
            // excludes loopback network 0.0.0.0
            // excludes reserved space >= 224.0.0.0
            // excludes network & broacast addresses
            // (first & last IP address of each class)
            "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*" + tld + ")(?::\\d{2,5})?(?:[/?#]\\S*)?$";
            if (allowDataUrl) {
              var mediaType = "\\w+\\/[-+.\\w]+(?:;[\\w=]+)*";
              var urlchar = "[A-Za-z0-9-_.!~\\*'();\\/?:@&=+$,%]*";
              var dataurl = "data:(?:" + mediaType + ")?(?:;base64)?," + urlchar;
              regex = "(?:" + regex + ")|(?:^" + dataurl + "$)";
            }
            var PATTERN = new RegExp(regex, "i");
            if (!PATTERN.exec(value)) {
              return message;
            }
          },
          type: v.extend(function(value, originalOptions, attribute, attributes, globalOptions) {
            if (v.isString(originalOptions)) {
              originalOptions = { type: originalOptions };
            }
            if (!v.isDefined(value)) {
              return;
            }
            var options = v.extend({}, this.options, originalOptions);
            var type = options.type;
            if (!v.isDefined(type)) {
              throw new Error("No type was specified");
            }
            var check;
            if (v.isFunction(type)) {
              check = type;
            } else {
              check = this.types[type];
            }
            if (!v.isFunction(check)) {
              throw new Error("validate.validators.type.types." + type + " must be a function.");
            }
            if (!check(value, options, attribute, attributes, globalOptions)) {
              var message = originalOptions.message || this.messages[type] || this.message || options.message || (v.isFunction(type) ? "must be of the correct type" : "must be of type %{type}");
              if (v.isFunction(message)) {
                message = message(value, originalOptions, attribute, attributes, globalOptions);
              }
              return v.format(message, { attribute: v.prettify(attribute), type });
            }
          }, {
            types: {
              object: function(value) {
                return v.isObject(value) && !v.isArray(value);
              },
              array: v.isArray,
              integer: v.isInteger,
              number: v.isNumber,
              string: v.isString,
              date: v.isDate,
              boolean: v.isBoolean
            },
            messages: {}
          })
        };
        validate2.formatters = {
          detailed: function(errors) {
            return errors;
          },
          flat: v.flattenErrorsToArray,
          grouped: function(errors) {
            var attr;
            errors = v.groupErrorsByAttribute(errors);
            for (attr in errors) {
              errors[attr] = v.flattenErrorsToArray(errors[attr]);
            }
            return errors;
          },
          constraint: function(errors) {
            var attr;
            errors = v.groupErrorsByAttribute(errors);
            for (attr in errors) {
              errors[attr] = errors[attr].map(function(result) {
                return result.validator;
              }).sort();
            }
            return errors;
          }
        };
        validate2.exposeModule(validate2, this, exports2, module2, define2);
      }).call(
        exports,
        typeof exports !== "undefined" ? (
          /* istanbul ignore next */
          exports
        ) : null,
        typeof module !== "undefined" ? (
          /* istanbul ignore next */
          module
        ) : null,
        typeof define !== "undefined" ? (
          /* istanbul ignore next */
          define
        ) : null
      );
    }
  });

  // src/js/e-signature.js
  var import_validate = __toESM(require_validate(), 1);

  // package.json
  var version = "v1.2.3";

  // ../../node_modules/signature_pad/dist/signature_pad.js
  var Point = class {
    constructor(x, y, pressure, time) {
      if (isNaN(x) || isNaN(y)) {
        throw new Error(`Point is invalid: (${x}, ${y})`);
      }
      this.x = +x;
      this.y = +y;
      this.pressure = pressure || 0;
      this.time = time || Date.now();
    }
    distanceTo(start) {
      return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
    }
    equals(other) {
      return this.x === other.x && this.y === other.y && this.pressure === other.pressure && this.time === other.time;
    }
    velocityFrom(start) {
      return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 0;
    }
  };
  var Bezier = class _Bezier {
    static fromPoints(points, widths) {
      const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;
      const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;
      return new _Bezier(points[1], c2, c3, points[2], widths.start, widths.end);
    }
    static calculateControlPoints(s1, s2, s3) {
      const dx1 = s1.x - s2.x;
      const dy1 = s1.y - s2.y;
      const dx2 = s2.x - s3.x;
      const dy2 = s2.y - s3.y;
      const m1 = { x: (s1.x + s2.x) / 2, y: (s1.y + s2.y) / 2 };
      const m2 = { x: (s2.x + s3.x) / 2, y: (s2.y + s3.y) / 2 };
      const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
      const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
      const dxm = m1.x - m2.x;
      const dym = m1.y - m2.y;
      const k = l2 / (l1 + l2);
      const cm = { x: m2.x + dxm * k, y: m2.y + dym * k };
      const tx = s2.x - cm.x;
      const ty = s2.y - cm.y;
      return {
        c1: new Point(m1.x + tx, m1.y + ty),
        c2: new Point(m2.x + tx, m2.y + ty)
      };
    }
    constructor(startPoint, control2, control1, endPoint, startWidth, endWidth) {
      this.startPoint = startPoint;
      this.control2 = control2;
      this.control1 = control1;
      this.endPoint = endPoint;
      this.startWidth = startWidth;
      this.endWidth = endWidth;
    }
    length() {
      const steps = 10;
      let length = 0;
      let px;
      let py;
      for (let i = 0; i <= steps; i += 1) {
        const t = i / steps;
        const cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
        const cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
        if (i > 0) {
          const xdiff = cx - px;
          const ydiff = cy - py;
          length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
        }
        px = cx;
        py = cy;
      }
      return length;
    }
    point(t, start, c1, c2, end) {
      return start * (1 - t) * (1 - t) * (1 - t) + 3 * c1 * (1 - t) * (1 - t) * t + 3 * c2 * (1 - t) * t * t + end * t * t * t;
    }
  };
  var SignatureEventTarget = class {
    constructor() {
      try {
        this._et = new EventTarget();
      } catch (error) {
        this._et = document;
      }
    }
    addEventListener(type, listener, options) {
      this._et.addEventListener(type, listener, options);
    }
    dispatchEvent(event) {
      return this._et.dispatchEvent(event);
    }
    removeEventListener(type, callback, options) {
      this._et.removeEventListener(type, callback, options);
    }
  };
  function throttle(fn, wait = 250) {
    let previous = 0;
    let timeout = null;
    let result;
    let storedContext;
    let storedArgs;
    const later = () => {
      previous = Date.now();
      timeout = null;
      result = fn.apply(storedContext, storedArgs);
      if (!timeout) {
        storedContext = null;
        storedArgs = [];
      }
    };
    return function wrapper(...args) {
      const now = Date.now();
      const remaining = wait - (now - previous);
      storedContext = this;
      storedArgs = args;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = fn.apply(storedContext, storedArgs);
        if (!timeout) {
          storedContext = null;
          storedArgs = [];
        }
      } else if (!timeout) {
        timeout = window.setTimeout(later, remaining);
      }
      return result;
    };
  }
  var SignaturePad = class _SignaturePad extends SignatureEventTarget {
    constructor(canvas, options = {}) {
      super();
      this.canvas = canvas;
      this._drawingStroke = false;
      this._isEmpty = true;
      this._lastPoints = [];
      this._data = [];
      this._lastVelocity = 0;
      this._lastWidth = 0;
      this._handleMouseDown = (event) => {
        if (event.buttons === 1) {
          this._strokeBegin(event);
        }
      };
      this._handleMouseMove = (event) => {
        this._strokeMoveUpdate(event);
      };
      this._handleMouseUp = (event) => {
        if (event.buttons === 1) {
          this._strokeEnd(event);
        }
      };
      this._handleTouchStart = (event) => {
        if (event.cancelable) {
          event.preventDefault();
        }
        if (event.targetTouches.length === 1) {
          const touch = event.changedTouches[0];
          this._strokeBegin(touch);
        }
      };
      this._handleTouchMove = (event) => {
        if (event.cancelable) {
          event.preventDefault();
        }
        const touch = event.targetTouches[0];
        this._strokeMoveUpdate(touch);
      };
      this._handleTouchEnd = (event) => {
        const wasCanvasTouched = event.target === this.canvas;
        if (wasCanvasTouched) {
          if (event.cancelable) {
            event.preventDefault();
          }
          const touch = event.changedTouches[0];
          this._strokeEnd(touch);
        }
      };
      this._handlePointerStart = (event) => {
        event.preventDefault();
        this._strokeBegin(event);
      };
      this._handlePointerMove = (event) => {
        this._strokeMoveUpdate(event);
      };
      this._handlePointerEnd = (event) => {
        if (this._drawingStroke) {
          event.preventDefault();
          this._strokeEnd(event);
        }
      };
      this.velocityFilterWeight = options.velocityFilterWeight || 0.7;
      this.minWidth = options.minWidth || 0.5;
      this.maxWidth = options.maxWidth || 2.5;
      this.throttle = "throttle" in options ? options.throttle : 16;
      this.minDistance = "minDistance" in options ? options.minDistance : 5;
      this.dotSize = options.dotSize || 0;
      this.penColor = options.penColor || "black";
      this.backgroundColor = options.backgroundColor || "rgba(0,0,0,0)";
      this.compositeOperation = options.compositeOperation || "source-over";
      this._strokeMoveUpdate = this.throttle ? throttle(_SignaturePad.prototype._strokeUpdate, this.throttle) : _SignaturePad.prototype._strokeUpdate;
      this._ctx = canvas.getContext("2d");
      this.clear();
      this.on();
    }
    clear() {
      const { _ctx: ctx, canvas } = this;
      ctx.fillStyle = this.backgroundColor;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      this._data = [];
      this._reset(this._getPointGroupOptions());
      this._isEmpty = true;
    }
    fromDataURL(dataUrl, options = {}) {
      return new Promise((resolve, reject) => {
        const image = new Image();
        const ratio = options.ratio || window.devicePixelRatio || 1;
        const width = options.width || this.canvas.width / ratio;
        const height = options.height || this.canvas.height / ratio;
        const xOffset = options.xOffset || 0;
        const yOffset = options.yOffset || 0;
        this._reset(this._getPointGroupOptions());
        image.onload = () => {
          this._ctx.drawImage(image, xOffset, yOffset, width, height);
          resolve();
        };
        image.onerror = (error) => {
          reject(error);
        };
        image.crossOrigin = "anonymous";
        image.src = dataUrl;
        this._isEmpty = false;
      });
    }
    toDataURL(type = "image/png", encoderOptions) {
      switch (type) {
        case "image/svg+xml":
          if (typeof encoderOptions !== "object") {
            encoderOptions = void 0;
          }
          return `data:image/svg+xml;base64,${btoa(this.toSVG(encoderOptions))}`;
        default:
          if (typeof encoderOptions !== "number") {
            encoderOptions = void 0;
          }
          return this.canvas.toDataURL(type, encoderOptions);
      }
    }
    on() {
      this.canvas.style.touchAction = "none";
      this.canvas.style.msTouchAction = "none";
      this.canvas.style.userSelect = "none";
      const isIOS = /Macintosh/.test(navigator.userAgent) && "ontouchstart" in document;
      if (window.PointerEvent && !isIOS) {
        this._handlePointerEvents();
      } else {
        this._handleMouseEvents();
        if ("ontouchstart" in window) {
          this._handleTouchEvents();
        }
      }
    }
    off() {
      this.canvas.style.touchAction = "auto";
      this.canvas.style.msTouchAction = "auto";
      this.canvas.style.userSelect = "auto";
      this.canvas.removeEventListener("pointerdown", this._handlePointerStart);
      this.canvas.removeEventListener("pointermove", this._handlePointerMove);
      this.canvas.ownerDocument.removeEventListener("pointerup", this._handlePointerEnd);
      this.canvas.removeEventListener("mousedown", this._handleMouseDown);
      this.canvas.removeEventListener("mousemove", this._handleMouseMove);
      this.canvas.ownerDocument.removeEventListener("mouseup", this._handleMouseUp);
      this.canvas.removeEventListener("touchstart", this._handleTouchStart);
      this.canvas.removeEventListener("touchmove", this._handleTouchMove);
      this.canvas.removeEventListener("touchend", this._handleTouchEnd);
    }
    isEmpty() {
      return this._isEmpty;
    }
    fromData(pointGroups, { clear = true } = {}) {
      if (clear) {
        this.clear();
      }
      this._fromData(pointGroups, this._drawCurve.bind(this), this._drawDot.bind(this));
      this._data = this._data.concat(pointGroups);
    }
    toData() {
      return this._data;
    }
    _getPointGroupOptions(group) {
      return {
        penColor: group && "penColor" in group ? group.penColor : this.penColor,
        dotSize: group && "dotSize" in group ? group.dotSize : this.dotSize,
        minWidth: group && "minWidth" in group ? group.minWidth : this.minWidth,
        maxWidth: group && "maxWidth" in group ? group.maxWidth : this.maxWidth,
        velocityFilterWeight: group && "velocityFilterWeight" in group ? group.velocityFilterWeight : this.velocityFilterWeight,
        compositeOperation: group && "compositeOperation" in group ? group.compositeOperation : this.compositeOperation
      };
    }
    _strokeBegin(event) {
      const cancelled = !this.dispatchEvent(new CustomEvent("beginStroke", { detail: event, cancelable: true }));
      if (cancelled) {
        return;
      }
      this._drawingStroke = true;
      const pointGroupOptions = this._getPointGroupOptions();
      const newPointGroup = Object.assign(Object.assign({}, pointGroupOptions), { points: [] });
      this._data.push(newPointGroup);
      this._reset(pointGroupOptions);
      this._strokeUpdate(event);
    }
    _strokeUpdate(event) {
      if (!this._drawingStroke) {
        return;
      }
      if (this._data.length === 0) {
        this._strokeBegin(event);
        return;
      }
      this.dispatchEvent(new CustomEvent("beforeUpdateStroke", { detail: event }));
      const x = event.clientX;
      const y = event.clientY;
      const pressure = event.pressure !== void 0 ? event.pressure : event.force !== void 0 ? event.force : 0;
      const point = this._createPoint(x, y, pressure);
      const lastPointGroup = this._data[this._data.length - 1];
      const lastPoints = lastPointGroup.points;
      const lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];
      const isLastPointTooClose = lastPoint ? point.distanceTo(lastPoint) <= this.minDistance : false;
      const pointGroupOptions = this._getPointGroupOptions(lastPointGroup);
      if (!lastPoint || !(lastPoint && isLastPointTooClose)) {
        const curve = this._addPoint(point, pointGroupOptions);
        if (!lastPoint) {
          this._drawDot(point, pointGroupOptions);
        } else if (curve) {
          this._drawCurve(curve, pointGroupOptions);
        }
        lastPoints.push({
          time: point.time,
          x: point.x,
          y: point.y,
          pressure: point.pressure
        });
      }
      this.dispatchEvent(new CustomEvent("afterUpdateStroke", { detail: event }));
    }
    _strokeEnd(event) {
      if (!this._drawingStroke) {
        return;
      }
      this._strokeUpdate(event);
      this._drawingStroke = false;
      this.dispatchEvent(new CustomEvent("endStroke", { detail: event }));
    }
    _handlePointerEvents() {
      this._drawingStroke = false;
      this.canvas.addEventListener("pointerdown", this._handlePointerStart);
      this.canvas.addEventListener("pointermove", this._handlePointerMove);
      this.canvas.ownerDocument.addEventListener("pointerup", this._handlePointerEnd);
    }
    _handleMouseEvents() {
      this._drawingStroke = false;
      this.canvas.addEventListener("mousedown", this._handleMouseDown);
      this.canvas.addEventListener("mousemove", this._handleMouseMove);
      this.canvas.ownerDocument.addEventListener("mouseup", this._handleMouseUp);
    }
    _handleTouchEvents() {
      this.canvas.addEventListener("touchstart", this._handleTouchStart);
      this.canvas.addEventListener("touchmove", this._handleTouchMove);
      this.canvas.addEventListener("touchend", this._handleTouchEnd);
    }
    _reset(options) {
      this._lastPoints = [];
      this._lastVelocity = 0;
      this._lastWidth = (options.minWidth + options.maxWidth) / 2;
      this._ctx.fillStyle = options.penColor;
      this._ctx.globalCompositeOperation = options.compositeOperation;
    }
    _createPoint(x, y, pressure) {
      const rect = this.canvas.getBoundingClientRect();
      return new Point(x - rect.left, y - rect.top, pressure, (/* @__PURE__ */ new Date()).getTime());
    }
    _addPoint(point, options) {
      const { _lastPoints } = this;
      _lastPoints.push(point);
      if (_lastPoints.length > 2) {
        if (_lastPoints.length === 3) {
          _lastPoints.unshift(_lastPoints[0]);
        }
        const widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2], options);
        const curve = Bezier.fromPoints(_lastPoints, widths);
        _lastPoints.shift();
        return curve;
      }
      return null;
    }
    _calculateCurveWidths(startPoint, endPoint, options) {
      const velocity = options.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - options.velocityFilterWeight) * this._lastVelocity;
      const newWidth = this._strokeWidth(velocity, options);
      const widths = {
        end: newWidth,
        start: this._lastWidth
      };
      this._lastVelocity = velocity;
      this._lastWidth = newWidth;
      return widths;
    }
    _strokeWidth(velocity, options) {
      return Math.max(options.maxWidth / (velocity + 1), options.minWidth);
    }
    _drawCurveSegment(x, y, width) {
      const ctx = this._ctx;
      ctx.moveTo(x, y);
      ctx.arc(x, y, width, 0, 2 * Math.PI, false);
      this._isEmpty = false;
    }
    _drawCurve(curve, options) {
      const ctx = this._ctx;
      const widthDelta = curve.endWidth - curve.startWidth;
      const drawSteps = Math.ceil(curve.length()) * 2;
      ctx.beginPath();
      ctx.fillStyle = options.penColor;
      for (let i = 0; i < drawSteps; i += 1) {
        const t = i / drawSteps;
        const tt = t * t;
        const ttt = tt * t;
        const u = 1 - t;
        const uu = u * u;
        const uuu = uu * u;
        let x = uuu * curve.startPoint.x;
        x += 3 * uu * t * curve.control1.x;
        x += 3 * u * tt * curve.control2.x;
        x += ttt * curve.endPoint.x;
        let y = uuu * curve.startPoint.y;
        y += 3 * uu * t * curve.control1.y;
        y += 3 * u * tt * curve.control2.y;
        y += ttt * curve.endPoint.y;
        const width = Math.min(curve.startWidth + ttt * widthDelta, options.maxWidth);
        this._drawCurveSegment(x, y, width);
      }
      ctx.closePath();
      ctx.fill();
    }
    _drawDot(point, options) {
      const ctx = this._ctx;
      const width = options.dotSize > 0 ? options.dotSize : (options.minWidth + options.maxWidth) / 2;
      ctx.beginPath();
      this._drawCurveSegment(point.x, point.y, width);
      ctx.closePath();
      ctx.fillStyle = options.penColor;
      ctx.fill();
    }
    _fromData(pointGroups, drawCurve, drawDot) {
      for (const group of pointGroups) {
        const { points } = group;
        const pointGroupOptions = this._getPointGroupOptions(group);
        if (points.length > 1) {
          for (let j = 0; j < points.length; j += 1) {
            const basicPoint = points[j];
            const point = new Point(basicPoint.x, basicPoint.y, basicPoint.pressure, basicPoint.time);
            if (j === 0) {
              this._reset(pointGroupOptions);
            }
            const curve = this._addPoint(point, pointGroupOptions);
            if (curve) {
              drawCurve(curve, pointGroupOptions);
            }
          }
        } else {
          this._reset(pointGroupOptions);
          drawDot(points[0], pointGroupOptions);
        }
      }
    }
    toSVG({ includeBackgroundColor = false } = {}) {
      const pointGroups = this._data;
      const ratio = Math.max(window.devicePixelRatio || 1, 1);
      const minX = 0;
      const minY = 0;
      const maxX = this.canvas.width / ratio;
      const maxY = this.canvas.height / ratio;
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      svg.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
      svg.setAttribute("viewBox", `${minX} ${minY} ${maxX} ${maxY}`);
      svg.setAttribute("width", maxX.toString());
      svg.setAttribute("height", maxY.toString());
      if (includeBackgroundColor && this.backgroundColor) {
        const rect = document.createElement("rect");
        rect.setAttribute("width", "100%");
        rect.setAttribute("height", "100%");
        rect.setAttribute("fill", this.backgroundColor);
        svg.appendChild(rect);
      }
      this._fromData(pointGroups, (curve, { penColor }) => {
        const path = document.createElement("path");
        if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {
          const attr = `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(3)} C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;
          path.setAttribute("d", attr);
          path.setAttribute("stroke-width", (curve.endWidth * 2.25).toFixed(3));
          path.setAttribute("stroke", penColor);
          path.setAttribute("fill", "none");
          path.setAttribute("stroke-linecap", "round");
          svg.appendChild(path);
        }
      }, (point, { penColor, dotSize, minWidth, maxWidth }) => {
        const circle = document.createElement("circle");
        const size = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;
        circle.setAttribute("r", size.toString());
        circle.setAttribute("cx", point.x.toString());
        circle.setAttribute("cy", point.y.toString());
        circle.setAttribute("fill", penColor);
        svg.appendChild(circle);
      });
      return svg.outerHTML;
    }
  };

  // ../components/signature-pad/src/SignaturePad.js
  var SmartFileUpload = class _SmartFileUpload {
    static memoryLimit = 2048e3;
    static supportedTypes = ["image/jpeg", "image/png", "image/svg+xml"];
    static getHumanSize(numberOfBytes) {
      const units = ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
      const exponent = Math.min(
        Math.floor(Math.log(numberOfBytes) / Math.log(1024)),
        units.length - 1
      );
      const approx = numberOfBytes / 1024 ** exponent;
      const output = exponent === 0 ? `${numberOfBytes} bytes` : `${approx.toFixed(0)} ${units[exponent]}`;
      return output;
    }
    static getData(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          resolve(e.target.result);
        };
        reader.onerror = () => {
          reject(
            new Error(
              "An error occurred reading the file. Please check the file, and try again"
            )
          );
        };
        reader.readAsDataURL(file);
      });
    }
    static async retrieve(files) {
      if (files.length > 1) {
        throw new Error("Only one file upload is permitted at a time");
      }
      const file = files[0];
      if (!_SmartFileUpload.supportedTypes.includes(file.type)) {
        throw new Error(
          "Unsupported file format. Please ensure that you are providing a JPG, PNG or SVG image"
        );
      }
      if (file.size > _SmartFileUpload.memoryLimit) {
        throw new Error(
          `${file.name} is too large. Please ensure that the file is less than ${_SmartFileUpload.getHumanSize(
            _SmartFileUpload.memoryLimit
          )}.`
        );
      }
      const imageAsDataUrl = await _SmartFileUpload.getData(file);
      return imageAsDataUrl;
    }
  };
  var SignaturePad2 = class extends HTMLElement {
    constructor() {
      super();
    }
    connectedCallback() {
      const shadow = this.attachShadow({ mode: "open" });
      const style = document.createElement("style");
      style.textContent = `
:host {
  display: block;
  block-size: auto;
  inline-size: 30rem;
  max-inline-size: 100%;
  position: relative;
  --color-active: #2D2B2A;
  --color-default: #001096;
  --color-disabled: #848282;
}

:host::part(upload) {
  text-align: center;
}

:host::part(signature-controls) {
  display: inline-flex;
  position: absolute;
  top: 1rem;
  right: 1rem;
}

:host::part(upload) svg + * {
  margin-inline-start: .5rem;
}

:host::part(canvas) {
  background-color: #F9F0E7;
  --dot-bg: #F9F0E7;
  --dot-color: black;
  --dot-size: 1px;
  --dot-space: 22px;
  background:
    linear-gradient(90deg, var(--dot-bg) calc(var(--dot-space) - var(--dot-size)), transparent 1%) center / var(--dot-space) var(--dot-space),
    linear-gradient(var(--dot-bg) calc(var(--dot-space) - var(--dot-size)), transparent 1%) center / var(--dot-space) var(--dot-space),
    var(--dot-color);
  border-radius: 2rem;
  inline-size: 30rem;
  max-inline-size: 100%;
  aspect-ratio: 2 / 1;
}

:host::part(upload-preview-image) {
  max-inline-size: 10rem;
}

.visually-hidden {
  clip: rect(0 0 0 0); 
  clip-path: inset(50%);
  height: 1px;
  overflow: hidden;
  position: absolute;
  white-space: nowrap; 
  width: 1px;
}

button,
label {
  font: inherit;
  cursor: pointer;
}

label {
  display: inline-flex;
  text-decoration: underline;
}

label svg + * {
  margin-inline-start: .5rem;
}

[type="file"] {
  display: none;
}

.center {
  text-align: center;
  margin-inline: auto;
}

.color-red {
  color: red;
}

button[data-variant="icon"] {
  appearance: none;
  -webkit-appearance: none;
  background-color: transparent;
  border: 0px;
}

button[data-variant="text"] {
  appearance: none;
  -webkit-appearance: none;
  background-color: transparent;
  border: 0px;
  text-decoration: underline;
  display: inline-flex;
  align-items: baseline;
}

button[data-variant="solid"] {
  --button-color: var(--color-default);
  border-radius: 2.5rem;
  border: 0;
  background-color: transparent;
  color: #fff;
  cursor: pointer;
  inline-size: 100%;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  font-weight: 600;
  padding: .75rem 1.5rem;
  text-align: center;
  background-color: var(--button-color);
  border: 2px solid var(--button-color);
}

button:hover,
button:focus,
button:active {
  --button-color: var(--color-active);
}

button:disabled {
  --button-color: var(--color-disabled);
}
`;
      const wrapper = document.createElement("div");
      const errorMessage = document.createElement("div");
      errorMessage.innerHTML = `
      <p id="error" class="color-red | center"><p>
    `;
      const signatureControls = document.createElement("div");
      signatureControls.setAttribute("id", "controls");
      signatureControls.setAttribute("part", "signature-controls");
      signatureControls.innerHTML = `
      <button data-variant="icon" type="button" name="clear" id="clear">
        <span class="visually-hidden">
          Clear Signature
        </span>
        <svg fill="none" xmlns="http://www.w3.org/2000/svg" width="18" viewBox="0 0 17 18">
          <path d="M3.314 15.646a8.004 8.004 0 01-2.217-4.257 8.06 8.06 0 01.545-4.655l1.789.788a6.062 6.062 0 001.264 6.737 6.033 6.033 0 008.551 0c2.358-2.37 2.358-6.224 0-8.592a5.996 5.996 0 00-4.405-1.782l.662 2.354-3.128-.796-3.127-.796 2.25-2.324L7.748 0l.55 1.953a7.966 7.966 0 016.33 2.326 8.004 8.004 0 012.342 5.684 8.005 8.005 0 01-2.343 5.683A7.928 7.928 0 018.97 18a7.928 7.928 0 01-5.656-2.354z" fill="currentColor" />
        </svg>
      </button>
    `;
      const canvas = document.createElement("canvas");
      const closestVisibleAncestor = this.parentElement.closest(":not([hidden])");
      const visibleChild = closestVisibleAncestor.querySelector(":not([hidden])");
      const containerWidth = visibleChild.offsetWidth;
      const remInPx = getComputedStyle(document.documentElement).fontSize.split("px")[0];
      const componentInlineSize = getComputedStyle(this).inlineSize.split("px")[0];
      const componentMaxInlineSize = 30 * remInPx;
      const aspectRatio = 2;
      canvas.width = containerWidth < componentMaxInlineSize ? containerWidth : componentMaxInlineSize;
      canvas.height = (containerWidth < componentMaxInlineSize ? containerWidth : componentMaxInlineSize) / aspectRatio;
      canvas.setAttribute("id", "signature-canvas");
      canvas.setAttribute("part", "canvas");
      const uploadControl = document.createElement("div");
      uploadControl.setAttribute("id", "signature-upload-wrapper");
      uploadControl.innerHTML = `
      <p part="upload">
        <strong>or</strong>
        <label>
          <input type='file' onclick='this.value=null;' id='upload-signature' accept='image/jpeg, image/png, image/svg+xml' />
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none">
            <rect width="16" height="16" fill="#F9F0E7" rx="2"/>
            <mask id="sign" width="16" height="16" x="0" y="0" maskUnits="userSpaceOnUse" style="mask-type:alpha">
              <rect width="16" height="16" fill="#D9D9D9" rx="2"/>
            </mask>
            <g mask="url(#sign)">
              <path fill="#2D2B2A" d="M0 13.333h16V16H0z"/>
            </g>
            <path fill="#2D2B2A" fill-rule="evenodd" d="M2.69 7.346a.23.23 0 0 1 .059-.073.275.275 0 0 1 .284-.034c.07.036.146.064.224.084h.12c0-.012.105-.048.105-.395a.796.796 0 0 1 .211-.61.667.667 0 0 1 .607-.096c.202.061.39.154.555.275.194.138.38.286.555.443.146.134.31.25.489.347l.092.047c.119.06.238-.023.185-.143l-.04-.12a.817.817 0 0 1-.066-.694.675.675 0 0 1 .244-.273.774.774 0 0 1 .364-.12c.324-.028.651 0 .964.083h.026c.027-.861.225-1.83.82-2.523.593-.694 1.478-.993 2.205-.837.726.155 1.307.73 1.307 1.602 0 1.34-.872 2.26-1.915 2.93.471.374.85.835 1.11 1.351.027.046.05.094.065.144h.014a.55.55 0 0 0 .079.203.44.44 0 0 0 .04.18c.002.025.011.05.026.07h-.013c.037.17.041.344.013.515a.955.955 0 0 1-.188.493 1.097 1.097 0 0 1-.433.344 1.346 1.346 0 0 1-1.122.012 2.194 2.194 0 0 1-.846-.67 5.024 5.024 0 0 1-.462-.681h-.026a.502.502 0 0 0-.106-.144.014.014 0 0 1-.01-.003.011.011 0 0 1-.003-.009.035.035 0 0 1-.013-.023.047.047 0 0 1-.011-.017.626.626 0 0 0-.055-.163.24.24 0 0 0-.014-.095h.014a3.477 3.477 0 0 1-.198-.49 6.318 6.318 0 0 1-.278-1.699L7.51 6.51c-.243-.07-.5-.094-.753-.071-.158.024-.198.071-.211.107-.014.036-.04.168.053.359.092.191.171.478.118.658a.45.45 0 0 1-.21.25.66.66 0 0 1-.305.06 1.521 1.521 0 0 1-.568-.19 3.533 3.533 0 0 1-.58-.42 3.54 3.54 0 0 0-.49-.394 1.49 1.49 0 0 0-.409-.203c-.053-.024-.079-.024-.092-.012H4.05c-.014.012-.066.072-.066.275 0 .395-.12.705-.423.813a.813.813 0 0 1-.41.024 1.646 1.646 0 0 1-.343-.12.237.237 0 0 1-.126-.127.208.208 0 0 1 .007-.172Zm5.731.766c.068.204.152.404.251.598.011.053.03.105.053.155.036.068.08.132.132.191.02.05.047.099.08.144.085.152.186.296.303.43.167.22.389.4.647.526a.847.847 0 0 0 .687-.011.655.655 0 0 0 .247-.204.573.573 0 0 0 .11-.287 1.435 1.435 0 0 0-.04-.454h-.014a.496.496 0 0 0-.079-.335.491.491 0 0 0-.119-.191 3.842 3.842 0 0 0-1.017-1.16l-.356.18a.253.253 0 0 1-.193.027.248.248 0 0 1-.088-.041.22.22 0 0 1-.063-.07.219.219 0 0 1-.02-.172.242.242 0 0 1 .113-.14l.172-.083a3.388 3.388 0 0 0-.463-.251l-.58-.24c.022.47.101.935.237 1.388Zm.568-1.555c.24.12.474.252.7.395 1.017-.634 1.81-1.459 1.81-2.63 0-.67-.41-1.053-.912-1.16-.502-.108-1.189.083-1.704.669-.515.586-.7 1.47-.713 2.32v.083c.251.084.515.192.819.323Z" clip-rule="evenodd"/>
          </svg>
          <span>upload a signature</span>
        </label>
      </p>
    `;
      const publishSignatureContainer = document.createElement("p");
      publishSignatureContainer.innerHTML = `
      <button data-variant="solid" type="button" name="publish" id="publish">
        <span>
          Continue
        </span>
        <svg
          aria-hidden="true"
          width="25"
          height="24"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M7 12h11m0 0-4.588-4M18 12l-4.588 4"
            stroke="#fff"
            stroke-width="1.5"
            stroke-linecap="round"
            stroke-linejoin="round"
          />
        </svg>
      </button>
    `;
      wrapper.appendChild(errorMessage);
      wrapper.appendChild(signatureControls);
      wrapper.appendChild(canvas);
      if (this.allowUpload)
        wrapper.appendChild(uploadControl);
      wrapper.appendChild(publishSignatureContainer);
      shadow.appendChild(style);
      shadow.appendChild(wrapper);
      this.core = new SignaturePad(canvas);
      this.errorMessage = errorMessage.querySelector("#error");
      if (window) {
        window.onresize = this.resizeCanvas();
      }
      this.clearSignatureButton = signatureControls.querySelector("#clear");
      this.clearSignatureButton.addEventListener(
        "click",
        () => this.clearSignature()
      );
      this.uploadSignatureButton = uploadControl.querySelector("#upload-signature");
      this.uploadSignatureButton.addEventListener(
        "change",
        (event) => this.uploadSignature(event)
      );
      this.publishSignatureButton = publishSignatureContainer.querySelector("#publish");
      this.publishSignatureButton.addEventListener(
        "click",
        () => this.publishSignature()
      );
    }
    disconnectedCallback() {
      this.publishSignatureButton.removeEventListener(
        "click",
        () => this.publishSignature()
      );
      this.clearSignatureButton.removeEventListener(
        "click",
        () => this.clearSignature()
      );
      this.uploadSignatureButton.removeEventListener(
        "change",
        (event) => this.uploadSignature(event)
      );
    }
    // Adjust canvas coordinate space taking into account pixel ratio,
    // to make it look crisp on mobile devices.
    // This also causes canvas to be cleared.
    resizeCanvas() {
      const canvas = this.shadowRoot.querySelector("canvas");
      const ratio = Math.max(window.devicePixelRatio || 1, 1);
      canvas.width = (canvas.offsetWidth || canvas.width) * ratio;
      canvas.height = (canvas.offsetHeight || canvas.height) * ratio;
      canvas.getContext("2d").scale(ratio, ratio);
      this.core.fromData(this.core.toData());
    }
    publishSignature() {
      try {
        this.resetErrorMessage();
        const previewImage = this.shadowRoot.querySelector("img");
        let image = previewImage ? previewImage.src : void 0;
        if (!image && !this.core.isEmpty()) {
          image = this.core.toDataURL("image/svg+xml");
        }
        if (image) {
          this.dispatchEvent(
            new CustomEvent("signature-pad.publish", {
              detail: image
            })
          );
        } else {
          throw new Error(
            `No signature present. ${this.allowUpload ? "Draw or upload" : "Draw"} a signature`
          );
        }
      } catch (error) {
        this.handleError(error.message);
      }
    }
    resetErrorMessage() {
      this.errorMessage.textContent = "";
    }
    handleError(error) {
      this.errorMessage.textContent = error;
    }
    clearSignature() {
      this.resetErrorMessage();
      const canvas = this.shadowRoot.querySelector("canvas");
      const img = this.shadowRoot.querySelector("img");
      if (img) {
        img.remove();
        canvas.removeAttribute("hidden");
      }
      this.core.clear();
    }
    previewUpload(fileData) {
      const canvas = this.shadowRoot.querySelector("canvas");
      let img = this.shadowRoot.querySelector("img");
      if (!img) {
        img = document.createElement("img");
      }
      img.src = fileData;
      img.setAttribute("part", "upload-preview-image");
      canvas.setAttribute("hidden", true);
      canvas.insertAdjacentElement("afterend", img);
    }
    async uploadSignature(event) {
      try {
        this.resetErrorMessage();
        const { files } = event.target;
        const fileData = await SmartFileUpload.retrieve(files);
        this.previewUpload(fileData);
      } catch (error) {
        this.handleError(error.message);
      }
    }
    get allowUpload() {
      return this.hasAttribute("allow-upload");
    }
  };
  if ("customElements" in window) {
    window.customElements.define("smileid-signature-pad", SignaturePad2);
  }

  // ../components/navigation/src/Navigation.js
  var Navigation = class extends HTMLElement {
    constructor() {
      super();
    }
    connectedCallback() {
      const shadow = this.attachShadow({ mode: "open" });
      const style = document.createElement("style");
      style.textContent = `
:host {
  display: flex;
  max-inline-size: 100%;
  justify-content: ${this.showBackButton ? "space-between" : "flex-end"};
}

button {
  --button-color: var(--color-default);
  --flow-space: 3rem;
  -webkit-appearance: none;
  -moz-appearance: none;
  align-items: center;
  appearance: none;
  background-color: transparent;
  border-radius: 2.5rem;
  border: none;
  color: #ffffff;
  cursor: pointer;
  display: inline-flex;
  font-size: 20px;
  font-weight: 500;
  inline-size: 100%;
  justify-content: center;
  letter-spacing: 0.05ch;
  line-height: 1;
  padding: 1rem 2.5rem;
  text-align: center;
  text-decoration: none;
}

button[data-type="icon"] {
  align-items: center;
  background-color: transparent;
  border: 0;
  cursor: pointer;
  display: flex;
  padding: 0;
  width: auto;
}

:host::part(back-button) {
  display: flex;
  align-items: center;
}

:host::part(back-button-text) {
  line-height: 1;
  color: rgb(21, 31, 114) !important;
}

:host::part(close-button) {
}

.visually-hidden {
  clip: rect(0 0 0 0);
  clip-path: inset(50%);
  block-size: 1px;
  overflow: hidden;
  position: absolute;
  white-space: nowrap;
  inline-size: 1px;
}
    `;
      const backButton = document.createElement("button");
      backButton.setAttribute("class", "back-button");
      backButton.setAttribute("data-type", "icon");
      backButton.setAttribute("part", "back-button");
      backButton.setAttribute("type", "button");
      backButton.innerHTML = `
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="40"
        height="40"
        viewBox="0 0 24 24"
        fill="none"
      >
        <path
          fill="#DBDBC4"
          d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10Z"
          opacity=".4"
        />
        <path
          fill="#001096"
          d="M15.5 11.25h-5.19l1.72-1.72c.29-.29.29-.77 0-1.06a.754.754 0 0 0-1.06 0l-3 3c-.29.29-.29.77 0 1.06l3 3c.15.15.34.22.53.22s.38-.07.53-.22c.29-.29.29-.77 0-1.06l-1.72-1.72h5.19c.41 0 .75-.34.75-.75s-.34-.75-.75-.75Z"
        />
      </svg>
      <span part="back-button-text">Back</span>
    `;
      const closeButton = document.createElement("button");
      closeButton.setAttribute("class", "close-button");
      closeButton.setAttribute("data-type", "icon");
      closeButton.setAttribute("part", "close-button");
      closeButton.setAttribute("type", "button");
      closeButton.innerHTML = `
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        width="40"
        height="40"
        fill="none"
      >
        <path
          fill="#DBDBC4"
          d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10Z"
          opacity=".4"
        />
        <path
          fill="#91190F"
          d="m13.06 12 2.3-2.3c.29-.29.29-.77 0-1.06a.754.754 0 0 0-1.06 0l-2.3 2.3-2.3-2.3a.754.754 0 0 0-1.06 0c-.29.29-.29.77 0 1.06l2.3 2.3-2.3 2.3c-.29.29-.29.77 0 1.06.15.15.34.22.53.22s.38-.07.53-.22l2.3-2.3 2.3 2.3c.15.15.34.22.53.22s.38-.07.53-.22c.29-.29.29-.77 0-1.06l-2.3-2.3Z"
        />
      </svg>
      <span class="visually-hidden"
        >Close SmileIdentity Verification frame</span
      >
    `;
      shadow.appendChild(style);
      if (this.showBackButton)
        shadow.appendChild(backButton);
      shadow.appendChild(closeButton);
      this.backButton = backButton;
      this.backButton.addEventListener("click", () => this.handleBack());
      this.closeButton = closeButton;
      this.closeButton.addEventListener("click", () => this.handleClose());
    }
    disconnectedCallback() {
      this.backButton.removeEventListener("click", () => this.handleBack());
      this.closeButton.removeEventListener("click", () => this.handleClose());
    }
    handleBack() {
      this.dispatchEvent(
        new CustomEvent("navigation.back")
      );
    }
    handleClose() {
      this.dispatchEvent(
        new CustomEvent("navigation.close")
      );
    }
    get showBackButton() {
      return !this.hasAttribute("hide-back");
    }
  };
  if ("customElements" in window) {
    window.customElements.define("smileid-navigation", Navigation);
  }

  // src/js/e-signature.js
  function getHumanSize(numberOfBytes) {
    const units = ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
    const exponent = Math.min(
      Math.floor(Math.log(numberOfBytes) / Math.log(1024)),
      units.length - 1
    );
    const approx = numberOfBytes / 1024 ** exponent;
    const output = exponent === 0 ? `${numberOfBytes} bytes` : `${approx.toFixed(0)} ${units[exponent]}`;
    return output;
  }
  (function eSignature() {
    "use strict";
    function closeWindow(userTriggered) {
      const message = userTriggered ? "SmileIdentity::Close" : "SmileIdentity::Close::System";
      referenceWindow.postMessage(message, "*");
    }
    const endpoints = {
      development: "https://devapi.smileidentity.com/v1",
      sandbox: "https://testapi.smileidentity.com/v1",
      live: "https://api.smileidentity.com/v1",
      production: "https://api.smileidentity.com/v1"
    };
    const referenceWindow = window.parent;
    referenceWindow.postMessage("SmileIdentity::ChildPageReady", "*");
    function handleSuccess() {
      referenceWindow.postMessage("SmileIdentity::Success", "*");
    }
    function handleBadDocuments(error) {
      referenceWindow.postMessage(
        {
          message: "SmileIdentity::Error",
          data: {
            error
          }
        },
        "*"
      );
    }
    const visitedScreens = [];
    let activeScreen;
    function setActiveScreen(node, navigatingForward = true) {
      activeScreen.hidden = true;
      node.hidden = false;
      if (navigatingForward) {
        visitedScreens.push(activeScreen);
      }
      activeScreen = node;
    }
    const NavigationTargets = document.querySelectorAll("smileid-navigation");
    NavigationTargets.forEach((navigationTarget) => {
      navigationTarget.addEventListener(
        "navigation.back",
        () => {
          const screen = visitedScreens.pop();
          setActiveScreen(screen, false);
        },
        false
      );
      navigationTarget.addEventListener(
        "navigation.close",
        () => {
          closeWindow(true);
        },
        false
      );
    });
    const BackButtons = document.querySelectorAll(".back-button");
    BackButtons.forEach((button) => {
      button.addEventListener(
        "click",
        (event) => {
          event.preventDefault();
          const screen = visitedScreens.pop();
          setActiveScreen(screen, false);
        },
        false
      );
    });
    let config;
    let partner_params;
    let documents;
    let personal_info;
    let signature;
    function getPartnerParams() {
      function parseJWT(token) {
        const base64Url = token.split(".")[1];
        const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
        const jsonPayload = decodeURIComponent(
          atob(base64).split("").map(function(c) {
            return `%${c.charCodeAt(0).toString(16)}`;
          }).join("")
        );
        return JSON.parse(jsonPayload);
      }
      const { partner_params: partnerParams } = parseJWT(config.token);
      partner_params = { ...partnerParams, ...config.partner_params || {} };
    }
    async function getDocuments() {
      try {
        const {
          callback_url,
          token,
          partner_details: { partner_id }
        } = config;
        const URL = `${endpoints[config.environment]}/documents?ids=${config.document_ids.join(",")}`;
        const fetchConfig = {
          mode: "cors",
          headers: {
            "SmileID-Partner-ID": partner_id,
            "SmileID-Token": token
          }
        };
        const response = await fetch(URL, fetchConfig);
        const result = await response.json();
        if (response.ok) {
          return result;
        } else {
          handleBadDocuments(result.error);
          closeWindow();
        }
      } catch (e) {
        handleBadDocuments(e);
        closeWindow();
        throw new Error("Failed to retrieve documents", { cause: e });
      }
    }
    window.addEventListener(
      "message",
      async (event) => {
        if (event.data && event.data.includes("SmileIdentity::Configuration")) {
          config = JSON.parse(event.data);
          activeScreen = LoadingScreen;
          getPartnerParams();
          documents = (await getDocuments()).documents;
          initializeSession(documents);
        }
      },
      false
    );
    const LoadingScreen = document.querySelector("#loading-screen");
    activeScreen = LoadingScreen;
    const EntryScreen = document.querySelector("#entry-screen");
    const DocumentReviewScreen = document.querySelector(
      "#document-review-screen"
    );
    const PersonalInfoScreen = document.querySelector("#personal-info-screen");
    const PersonalInfoForm = PersonalInfoScreen.querySelector("form");
    const SignatureScreen = document.querySelector("#signature-screen");
    const ReviewSignatureScreen = document.querySelector(
      "#review-signature-screen"
    );
    const UploadProgressScreen = document.querySelector(
      "#upload-progress-screen"
    );
    const UploadFailedScreen = document.querySelector("#upload-failure-screen");
    const CompleteScreen = document.querySelector("#complete-screen");
    EntryScreen.querySelector("#getStarted").addEventListener(
      "click",
      () => setActiveScreen(DocumentReviewScreen)
    );
    DocumentReviewScreen.querySelector("#i_agree").addEventListener(
      "change",
      (event) => {
        const button = DocumentReviewScreen.querySelector("#agreeToTerms");
        if (event.target.checked) {
          button.removeAttribute("disabled");
        } else {
          button.setAttribute("disabled", true);
        }
      }
    );
    DocumentReviewScreen.querySelector("#agreeToTerms").addEventListener(
      "click",
      agreeToTerms
    );
    SignatureScreen.querySelector("smileid-signature-pad").addEventListener(
      "signature-pad.publish",
      (event) => {
        const name = ReviewSignatureScreen.querySelector("#name");
        name.textContent = personal_info.name;
        const image = ReviewSignatureScreen.querySelector("#preview-signature");
        image.src = event.detail;
        signature = dataURLToFile(event.detail);
        setActiveScreen(ReviewSignatureScreen);
      }
    );
    ReviewSignatureScreen.querySelector("#uploadSignature").addEventListener(
      "click",
      () => submitSignature()
    );
    UploadFailedScreen.querySelector("#retry-upload").addEventListener(
      "click",
      () => submitSignature()
    );
    function dataURLToFile(dataURL) {
      const parts = dataURL.split(";base64,");
      const contentType = parts[0].split(":")[1];
      const raw = window.atob(parts[1]);
      const rawLength = raw.length;
      const uInt8Array = new Uint8Array(rawLength);
      for (let i = 0; i < rawLength; ++i) {
        uInt8Array[i] = raw.charCodeAt(i);
      }
      const ext = {
        "image/jpeg": "jpg",
        "image/png": "png",
        "image/svg+xml": "svg"
      }[contentType];
      return new File(
        [new Blob([uInt8Array], { type: contentType })],
        `signature.${ext}`,
        { type: contentType }
      );
    }
    function initializeSession(documents2) {
      loadDocuments(documents2, DocumentReviewScreen);
      setActiveScreen(EntryScreen);
    }
    function validateInputs(payload) {
      const validationConstraints = {
        name: {
          presence: {
            allowEmpty: false,
            message: "is required"
          }
        }
      };
      const validation = (0, import_validate.default)(payload, validationConstraints);
      if (validation) {
        handleValidationErrors(validation);
        const submitButton = PersonalInfoForm.querySelector("[type='button']");
        submitButton.removeAttribute("disabled");
      }
      return validation;
    }
    function handleValidationErrors(errors) {
      const fields = Object.keys(errors);
      fields.forEach((field) => {
        const input = PersonalInfoForm.querySelector(`#${field}`);
        input.setAttribute("aria-invalid", "true");
        input.setAttribute("aria-describedby", `${field}-hint`);
        const errorDiv = document.createElement("div");
        errorDiv.setAttribute("id", `${field}-hint`);
        errorDiv.setAttribute("class", "validation-message");
        errorDiv.textContent = errors[field][0];
        input.insertAdjacentElement("afterend", errorDiv);
      });
    }
    function handlePersonalInfoSubmit(event) {
      if (event) {
        event.preventDefault();
        resetForm();
      }
      const formData = new FormData(PersonalInfoForm);
      const payload = {
        ...Object.fromEntries(formData.entries())
      };
      const isInvalid = validateInputs(payload);
      if (isInvalid) {
        return;
      }
      personal_info = {
        ...payload
      };
      setActiveScreen(SignatureScreen);
    }
    PersonalInfoForm.querySelector("#submitForm").addEventListener(
      "click",
      (event) => {
        handlePersonalInfoSubmit(event);
      },
      false
    );
    function loadDocuments(documents2, containerElement) {
      const placeholderElement = containerElement.querySelector(".document-list");
      const list = document.createElement("div");
      list.innerHTML = `
      <ul class="document-list">
        ${documents2.map(
        (document2) => `
                <li>
                  <a
                    href="${document2.link}"
                    target="_blank"
                    class="document-tips"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="19" fill="none">
                      <path fill="#fff" d="M1.786 18.698a1.47 1.47 0 0 1-1.484-1.454V1.776A1.47 1.47 0 0 1 1.786.293h9.144c.312-.01.624.127.83.36l3.024 3.026c.225.215.352.517.352.83v12.705a1.47 1.47 0 0 1-1.454 1.484H1.786Z"/>
                      <path fill="#FF2116" d="M10.93.586a.8.8 0 0 1 .624.263l3.025 3.025c.176.166.264.39.264.625v12.705c0 .654-.537 1.191-1.19 1.191H1.785c-.654 0-1.19-.537-1.19-1.19V1.775c0-.654.536-1.18 1.19-1.18h9.144m0-.596H1.786C.8 0 .01.8 0 1.776v15.438C0 18.2.8 18.99 1.786 19h11.876c.986 0 1.776-.8 1.786-1.786V4.508c.01-.39-.156-.77-.449-1.034L11.974.45A1.41 1.41 0 0 0 10.93 0Z"/>
                      <path fill="#FF2116" d="M11.369 8.558a1.071 1.071 0 0 0-.498-.263 3.229 3.229 0 0 0-.81-.098c-.185 0-.38.01-.566.03a7.98 7.98 0 0 0-.624.087 7.27 7.27 0 0 1-.381-.39c-.127-.137-.244-.293-.37-.459-.079-.117-.167-.234-.245-.36-.078-.118-.156-.235-.214-.352.107-.351.204-.693.273-1.005.068-.283.107-.576.107-.859 0-.215-.039-.44-.127-.634a.597.597 0 0 0-.556-.361.453.453 0 0 0-.39.224c-.108.195-.147.537-.098.937.059.459.195.917.39 1.337-.078.224-.156.449-.244.683-.087.234-.185.478-.292.742-.088.214-.186.429-.293.644-.107.214-.195.42-.312.624a7.406 7.406 0 0 0-1.464.752c-.361.253-.576.497-.605.722a.402.402 0 0 0 .01.215c.029.068.068.136.126.185a.965.965 0 0 0 .166.107c.088.04.186.059.274.059.35 0 .722-.254 1.073-.644.38-.44.712-.918.986-1.435a9.92 9.92 0 0 1 1.024-.312c.176-.049.38-.098.566-.137.186-.039.361-.068.537-.107.332.312.732.556 1.161.712.264.088.537.137.82.137.166.01.322-.02.478-.098a.379.379 0 0 0 .176-.214.52.52 0 0 0 .01-.274.28.28 0 0 0-.088-.195ZM7.114 4.196a.416.416 0 0 1 .107-.117.235.235 0 0 1 .147-.039c.097 0 .195.049.244.127a.678.678 0 0 1 .088.39c-.01.234-.04.469-.088.693a9.602 9.602 0 0 1-.244.937 4.158 4.158 0 0 1-.342-1.25c-.03-.34 0-.604.088-.74ZM4.196 10.56c.04-.186.225-.4.547-.615.4-.263.83-.488 1.278-.673-.244.429-.527.83-.859 1.19-.263.283-.507.44-.683.44a.345.345 0 0 1-.097-.02.23.23 0 0 1-.088-.059.344.344 0 0 1-.078-.127c-.02-.039-.02-.087-.02-.136Zm4.499-2.206c-.156.03-.322.059-.488.098-.166.03-.342.078-.507.117l-.44.117c-.146.04-.292.098-.429.147.078-.157.156-.303.234-.46.069-.146.137-.292.186-.438.068-.166.136-.332.195-.498.058-.166.127-.341.185-.507a5.24 5.24 0 0 0 .4.624c.108.137.215.283.322.41.108.127.225.263.342.39Zm.293.088c.322-.058.644-.088.966-.097.214-.01.43.01.644.039.117.02.224.078.302.175a.373.373 0 0 1 .069.303.357.357 0 0 1-.225.273.677.677 0 0 1-.439.03 3.114 3.114 0 0 1-.722-.293 6.103 6.103 0 0 1-.595-.43Z"/>
                      <path fill="#2C2C2C" d="M4.704 13.623v-.02l.01-.01h.01c.038 0 .087 0 .136-.009H5.377c.156 0 .302.02.449.068a.783.783 0 0 1 .312.186.69.69 0 0 1 .176.273c.039.107.058.224.058.341 0 .137-.029.284-.078.41a.78.78 0 0 1-.224.283 1.098 1.098 0 0 1-.722.215H5.142v.986s-.009 0-.009.01H4.723c-.01 0-.01-.01-.01-.01V14.286l-.01-.663Zm.449 1.337H5.357c.069 0 .147-.01.215-.02a.622.622 0 0 0 .186-.078.335.335 0 0 0 .126-.156.724.724 0 0 0 .05-.244.48.48 0 0 0-.147-.36.543.543 0 0 0-.166-.089.887.887 0 0 0-.225-.029H5.152v.976ZM6.821 13.633v-.02l.01-.01h.664c.185 0 .38.03.556.098.146.059.283.156.39.273.108.127.186.264.234.43.059.175.078.36.078.546.01.234-.039.469-.117.693-.126.322-.39.576-.732.683a1.333 1.333 0 0 1-.439.068h-.634s-.01 0-.01-.01V13.634Zm.459 2.332H7.485c.107 0 .224-.02.322-.059a.683.683 0 0 0 .254-.185c.078-.098.136-.205.175-.322.04-.146.069-.302.059-.459 0-.146-.02-.292-.059-.439a.874.874 0 0 0-.166-.292.55.55 0 0 0-.253-.166.84.84 0 0 0-.313-.05H7.26l.02 1.972ZM9.72 16.326v.02s0 .01-.01.01H9.27V13.602s.01 0 .01-.01h1.406s.01 0 .01.01c0 0 0 .01.01.01v.01l.009.088.01.088.01.088.01.087v.02s0 .01-.01.01c0 0-.01 0-.01.01H9.71v.79h.917s.01 0 .01.01v.39s0 .01-.01.01H9.71v1.102l.01.01Z"/>
                    </svg>

                    <div class="flow">
                      <p>${document2.name}<p>
                      <p>${getHumanSize(document2.size)}<p>
                    </div>
                  </a>
                </li>
              `
      ).join("\n")}
      </ul>
    `;
      placeholderElement.replaceWith(list);
      return list;
    }
    function agreeToTerms() {
      resetForm();
      const checkbox = DocumentReviewScreen.querySelector("#i_agree");
      if (checkbox.checked) {
        setActiveScreen(PersonalInfoScreen);
      } else {
        displayErrorMessage("You must tick the checkbox to proceed");
      }
    }
    function resetForm() {
      const invalidElements = PersonalInfoForm.querySelectorAll("[aria-invalid]");
      invalidElements.forEach((el) => el.removeAttribute("aria-invalid"));
      const validationMessages = document.querySelectorAll(".validation-message");
      validationMessages.forEach((el) => el.remove());
    }
    function displayErrorMessage(message) {
      const p = document.createElement("p");
      p.textContent = message;
      p.classList.add("validation-message");
      p.style.fontSize = "1.5rem";
      p.style.textAlign = "center";
      const main = document.querySelector("main");
      main.prepend(p);
    }
    async function submitSignature() {
      const headers = {
        "SmileID-Partner-ID": config.partner_details.partner_id,
        "SmileID-Token": config.token
      };
      const formData = new FormData();
      formData.append(
        "partner_params",
        JSON.stringify({
          ...partner_params,
          job_type: 12
        })
      );
      formData.append("callback_url", config.callback_url);
      formData.append("source_sdk", config.sdk || "hosted_web");
      formData.append("source_sdk_version", config.sdk_version || version);
      formData.append("smile_client_id", config.partner_details.partner_id);
      formData.append("ids", config.document_ids.join(","));
      formData.append("name", personal_info.name);
      formData.append("document_read_at", (/* @__PURE__ */ new Date()).toISOString());
      formData.append("image", signature);
      const URL = `${endpoints[config.environment] || config.environment}/documents/sign`;
      try {
        setActiveScreen(UploadProgressScreen);
        const response = await fetch(URL, {
          method: "POST",
          headers,
          body: formData
        });
        const json = await response.json();
        if (json.error)
          throw new Error(json.error);
        setActiveScreen(CompleteScreen);
        return json;
      } catch (error) {
        setActiveScreen(UploadFailedScreen);
        throw new Error("signature submission failed", { cause: error });
      }
    }
    function complete() {
      setActiveScreen(CompleteScreen);
      handleSuccess();
      window.setTimeout(closeWindow, 2e3);
    }
  })();
})();
/*! Bundled license information:

validate.js/validate.js:
  (*!
   * validate.js 0.13.1
   *
   * (c) 2013-2019 Nicklas Ansman, 2013 Wrapp
   * Validate.js may be freely distributed under the MIT license.
   * For all details and documentation:
   * http://validatejs.org/
   *)

signature_pad/dist/signature_pad.js:
  (*!
   * Signature Pad v4.1.7 | https://github.com/szimek/signature_pad
   * (c) 2023 Szymon Nowak | Released under the MIT license
   *)
*/
